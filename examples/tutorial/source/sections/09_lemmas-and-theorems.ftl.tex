\documentclass{stex}
\libinput{preamble}
\begin{document}

\section{Lemmas and Theorems}

After setting up the axiomatics we proceed to claim and prove
propositions. Claims together with the accumulated facts are
given to the background ATP (= eprover). Many basic
propositions can be proved by the ATP without further intervention.
The following three lemmas show that $\leq$ is a partial order:

\begin{forthel}

\begin{lemma} $m \leq m$.
\end{lemma}

\begin{axiom} If $m \leq n \leq m$
then $m = n$.
\end{axiom}

\begin{lemma} If $m \leq n \leq l$
then  $m \leq l$.
\end{lemma}
\end{forthel}

\subsection{Eprover in the Background}
These lemmas are checked correct by \Naproche{} without explicit proofs.
We can look at the tasks given to the ATP by putting
a [dump on] command in the beginning of the ForTheL parts of the
document and looking for the dump of the provertask in the
output window. The task is written in the first-order
logic language TPTP which is a standard input language for ATPs.
Observe that all previous Signature, Axiom and Definition
commands can be found as premises of the conjecture.

The following is part of the trace of proving $m \leq m$. Actually
the ontological correctness of the formula is checked first.
In case of the $\leq$-relation, the assumptions or presuppositions
were given by the pretypings of both arguments. So for the
formula $m \leq m$ we have to show that $m$ is a natural number.
This prover task is expressed by the following
TPTP text:
\begin{scriptsize}
\begin{verbatim}
[Translation] (line 409 of ...
aNaturalNumber(m)
[Translation] (line 409 of ...
m\leq m
[Reasoner] (line 409 of ...
goal:  m \leq m .
[Main] (line 409 of ...
fof(m_,hypothesis,$true).
fof(m_,hypothesis,aNaturalNumber(sz0)).
fof(m_,hypothesis,(aNaturalNumber(sz1) & ( ~ (sz1 = sz0)))).
fof(m_,hypothesis,( ! [W0] : ( ! [W1] : ((aNaturalNumber(W0) & aNaturalNumber(W1))
  => aNaturalNumber(sdtpldt(W0,W1)))))).
fof(m_,hypothesis,( ! [W0] : ( ! [W1] : ((aNaturalNumber(W0) & aNaturalNumber(W1))
  => aNaturalNumber(sdtasdt(W0,W1)))))).
fof(m_,hypothesis,( ! [W0] : ( ! [W1] : ((aNaturalNumber(W0) & aNaturalNumber(W1))
 => (sdtpldt(W0,W1) = sdtpldt(W1,W0)))))).
fof(m_,hypothesis,( ! [W0] : ( ! [W1] : ( ! [W2] : (((aNaturalNumber(W0) &
  aNaturalNumber(W1)) & aNaturalNumber(W2))
  => (sdtpldt(sdtpldt(W1,W2),W0) = sdtpldt(W1,sdtpldt(W2,W0)))))))).
fof(m_,hypothesis,( ! [W0] : (aNaturalNumber(W0)
  => ((sdtpldt(W0,sz0) = W0) & (W0 = sdtpldt(sz0,W0)))))).
fof(m_,hypothesis,( ! [W0] : ( ! [W1] : ((aNaturalNumber(W0) & aNaturalNumber(W1))
  => (sdtasdt(W0,W1) = sdtasdt(W1,W0)))))).
fof(m_,hypothesis,( ! [W0] : ( ! [W1] : ( ! [W2] : (((aNaturalNumber(W0) &
  aNaturalNumber(W1)) & aNaturalNumber(W2))
  => (sdtasdt(sdtasdt(W1,W2),W0) = sdtasdt(W1,sdtasdt(W2,W0)))))))).
fof(m_,hypothesis,( ! [W0] : (aNaturalNumber(W0)
  => ((sdtasdt(W0,sz1) = W0) & (W0 = sdtasdt(sz1,W0)))))).
fof(m_,hypothesis,( ! [W0] : (aNaturalNumber(W0)
  => ((sdtasdt(W0,sz0) = sz0) & (sz0 = sdtasdt(sz0,W0)))))).
fof(m_,hypothesis,( ! [W0] : ( ! [W1] : ( ! [W2] : (((aNaturalNumber(W0)
  & aNaturalNumber(W1)) & aNaturalNumber(W2))
  => ((sdtasdt(W1,sdtpldt(W2,W0)) = sdtpldt(sdtasdt(W1,W2),sdtasdt(W1,W0)))
  & (sdtasdt(sdtpldt(W2,W0),W1) = sdtpldt(sdtasdt(W2,W1),sdtasdt(W0,W1))))))))).
fof(m_,hypothesis,( ! [W0] : ( ! [W1] : ( ! [W2] : (((aNaturalNumber(W0)
  & aNaturalNumber(W1)) & aNaturalNumber(W2))
  => (((sdtpldt(W0,W1) = sdtpldt(W0,W2))
  | (sdtpldt(W1,W0) = sdtpldt(W2,W0))) => (W1 = W2))))))).
fof(m_,hypothesis,( ! [W0] : (aNaturalNumber(W0) => (( ~ (W0 = sz0))
  => ( ! [W1] : ( ! [W2] : ((aNaturalNumber(W1) & aNaturalNumber(W2))
  => (((sdtasdt(W0,W1) = sdtasdt(W0,W2))
  | (sdtasdt(W1,W0) = sdtasdt(W2,W0))) => (W1 = W2))))))))).
fof(m_,hypothesis,( ! [W0] : ( ! [W1] : ((aNaturalNumber(W0) & aNaturalNumber(W1))
  => ((sdtpldt(W0,W1) = sz0) => ((W0 = sz0) & (W1 = sz0))))))).
fof(m_,hypothesis,( ! [W0] : ( ! [W1] : ((aNaturalNumber(W0) & aNaturalNumber(W1))
  => (sdtbszlzezqdt(W0,W1)
  <=> ( ? [W2] : (aNaturalNumber(W2) & (sdtpldt(W0,W2) = W1)))))))).
fof(m_,hypothesis,( ! [W0] : ( ! [W1] : ((aNaturalNumber(W0) & aNaturalNumber(W1))
  => (sdtbszlzezqdt(W1,W0) => ((aNaturalNumber(sdtmndt(W0,W1))
  & (sdtpldt(W1,sdtmndt(W0,W1)) = W0)) & ( ! [W2] : ((aNaturalNumber(W2)
  & (sdtpldt(W1,W2) = W0)) => (W2 = sdtmndt(W0,W1)))))))))).
fof(m__,hypothesis,aNaturalNumber(xm)).
\end{verbatim}
\end{scriptsize}

\subsection{Testing for Contradictions}

It is quite common to accidentally introduce trivial inconsistencies
in formalizations. Not just by function definitions, but also
because some marginal cases outside the main argument have not
been treated right. E.g., although the number $0$ is quite
uninteresting for the study of prime numbers, we still have to
deal with $0$-cases or explicitly request that terms are
nonzero. If a text with non-trivial mathematical content checks
unexpectedly fast then one should become suspicious, because
eprover may exploit a contradiction to prove every proposition via
\textit{ex falso quodlibet}.

To find inconsistencies it is helpful to try to prove
\begin{lemma} Contradiction. \end{lemma}
\noindent in various places of a text. If the lemma is validated by
\Naproche{} then one has to investigate further. Contradiction-
lemmas can be quickly de-activated by commenting out
with \verb+%+.. They can also be used to force rechecking of
the text: uncomment
the lemma and then comment it again; this will lead to rechecking
from the position of the lemma onwards.

\end{document}
